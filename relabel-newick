#!/bin/bash
#
#  relabel-newick - relabel nodes in a newick format file
#  Copyright (C) 2017  Marco van Zwetselaar <io@zwets.it>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  Home: https://github.com/zwets/phylo-utils

# Function to exit this script with an error message on stderr
err_exit() {
    echo "$(basename "$0"): $*" >&2
    exit 1
}

# Function to exit this script on parse error
parse_error() {
    err_exit "parse error${1:+: $1} at: ${TOK}${BUF}"
}

# Function to show usage information and exit
usage_exit() {
    echo "
Usage: $(basename "$0") [OPTIONS] [FILE [RULES]]

  Read phylogenetic TREE from Newick format FILE, apply the rewrite rules
  from file RULES to the node labels of TREE, and write the resulting tree
  to standard output.  When RULES is absent or '-', read rules from standard
  input.  When FILE is absent or '-' read TREE from standard input.
  
  RULES must have lines of colon-separated values OLD:NEW.  OLD is an
  extended regex(7) whose anchored match with any label of the tree is
  changed to NEW.  By 'anchored' is meant that OLD is interpreted as ^OLD\$,
  in other words, it must match the whole label.  NEW may be any string not 
  containing characters that Newick disallows (notably (),:;), and may have
  backreferences \\1..\\9 as with the substitute command in sed(1).
  
  OPTIONS
   -v,--verbose  produce verbose output on stderr
   -h,--help     this help
  
  RULE EXAMPLES
  # Replace label '1' with 'ONE' and '42' with 'LTUAE'
  1:ONE
  42:LTUAE
  # Prepend NR to any label that is entirely numeric
  ([0-9]\\+):NR\\1
  # Remove suffix starting with first full stop from left
  ([^/]*)\\..*1
  # Remove suffix starting with last full stop
  (.*)\\..*:\\1
  "
    exit ${1:-1}
}

# Newick tree parser

# - Newick BNF syntax (condensed from the overblown Wikipedia entry)
#   Tree   ::= Branch ';'
#   Branch ::= ['('Branch [','Branch ...]')'] [name] [':'length]

# Holds the current state of the parser
TOK=""
BUF=""

# Tokeniser - tokens are the five characters ( ) , : , or a sequence of anything else
next_Token() {
    local C="$(expr "$BUF" : '^ *\(.\?\).*')"
    case "$C" in
    '') TOK=''
        BUF=''
        ;;
    '('|','|')'|':'|';')
        TOK="$C"
        BUF="$(expr "$BUF" : '^ *.\(.*\)')"
        ;;
    *)
        TOK="$(expr "$BUF" : '^ *\([^(,):;]\+\).*')"
        BUF="$(expr "$BUF" : '^ *[^(,):;]\+\(.*\)')"
        ;;
    esac
    true
}

# Try and parse next token, which if $1 is given must equal $1
try_parse() {
    [ $# -ne 1 ] || [ "$TOK" = "$1" ] || return 1
    printf "$TOK"
    next_Token
}

parse_Tree() {
    parse_Branch
    parse_Char ';'
}

parse_Branch() {
    opt_parse_List
    opt_parse_Name
    opt_parse_Length
}

opt_parse_List() {
    try_parse '(' && parse_Branch && opt_parse_Branches && parse_Char ')' ||
    true
}

opt_parse_Branches() {
    try_parse ',' && parse_Branch && opt_parse_Branches ||
    true
}

opt_parse_Name() { # Note requires SED_PROG to have the s:OLD:NEW: rules
    expr "$TOK" : '[^(,):;]*' >/dev/null && printf "$TOK" | sed -r -e "$SED_PROG" && next_Token ||
    true
}

opt_parse_Length() {
    try_parse ':' && parse_Length ||
    true
}

parse_Length() {
    expr "$TOK" : '^\([0-9]\+\(\.[0-9]\+\)\?\)$' >/dev/null && printf "$TOK" && next_Token ||
    parse_error "expected number"
}

parse_Char() {
    try_parse "$1" || parse_error "expecting '$1'"
}

# Rewrite the multiline string on stdin to a sed program on stdout
rules_to_sed() {
    while read -r LINE; do
        # Ignore empty lines 
        [ -n "$LINE" ] || continue
        # Ignore comment lines (starting with '#' and NOT having ':')
        expr "$LINE" : '#[^:]*$' >/dev/null && continue
        expr "$LINE" : '.*:' >/dev/null || err_exit "line contains no colon character: $LINE"
        echo -n "s:^${LINE%%:*}\$:${LINE#*:}:;"
    done
}

# Main

# Parse options
while [ $# -ne 0 -a "$(expr "$1" : '\(.\)..*')" = "-" ]; do
    case $1 in
    -v|--verbose) VERBOSE=1 ;;
    -h|--help) usage_exit 0 ;;
    *) usage_exit ;;
    esac
    shift
done

# Parse and check arguments
[ $# -le 2 ] || usage_exit
FILE1="-"
FILE2="-"
[ $# -lt 2 ] || FILE2="$2"
[ $# -lt 1 ] || FILE1="$1"
[ "$FILE1" != "-" ] || FILE1="/dev/stdin"
[ "$FILE2" != "-" ] || FILE2="/dev/stdin"
[ -r "$FILE1" ] || err_exit "cannot read file: $FILE1"
[ -r "$FILE2" ] || err_exit "cannot read file: $FILE2"

# Read the input, handling the case where both are read from same file (stdin),
# noting that Newick ends at the first ';', so we splice it there.
if [ "$FILE1" = "$FILE2" ]; then
    ALL_INPUT="$(cat "$FILE1")"
    BUF="${ALL_INPUT%%;*};"
    RULES="${ALL_INPUT#;}"
    unset ALL_INPUT
else
    BUF="$(cat "$FILE1")"
    RULES="$(cat "$FILE2")"
fi

# Convert the rules to sed program
SED_PROG="$(echo "$RULES" | rules_to_sed)"

# Do the actual work
next_Token
parse_Tree
echo

# vim: sts=4:sw=4:et:ai:si
